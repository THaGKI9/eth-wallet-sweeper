{"version":3,"file":"static/chunks/8436.80e5ac7f57305ddc.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/ws.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js","webpack://_N_E/./node_modules/@ethersproject/random/lib.esm/shuffle.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/infura-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js","webpack://_N_E/./node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        super(url, network);\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n        this._websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this._websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this._websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this._websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this._websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this._websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        logger.checkNew(new.target, EtherscanProvider);\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map","\"use strict\";\nexport function shuffled(array) {\n    array = array.slice();\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    return array;\n}\n//# sourceMappingURL=shuffle.js.map","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n//# sourceMappingURL=ipc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map","\"use strict\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// These are load-balancer-based application IDs\nconst defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nexport class PocketProvider extends UrlJsonRpcProvider {\n    constructor(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        if (apiKey == null) {\n            const n = getStatic(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        super(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        }\n        else {\n            url = `https:/\\/${host}/v1/${apiKey.applicationId}`;\n        }\n        const connection = { url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["WS","WebSocket","Error","error","logger","throwError","operation","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","connection","detectNetwork","_websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","static","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","onerror","close","StaticJsonRpcProvider","_super","create","get","call","_network","UrlJsonRpcProvider","apiKey","checkAbstract","key","_startPending","isCommunityResource","getSigner","address","listAccounts","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","replace","throwArgumentError","host","name","arguments","allowGzip","throttleCallback","attempt","CloudflareProvider","perform","blockTag","getTransactionPostData","transaction","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","map","set","storageKeys","join","getResult","status","toLowerCase","indexOf","throttleRetry","getJsonResult","checkLogTag","parseInt","substring","checkError","match","body","responseText","EtherscanProvider","checkNew","getBaseUrl","getUrl","module","query","reduce","accum","baseUrl","getPostUrl","getPostData","apikey","fetch","post","procFunc","throttleSlotInterval","payloadStr","headers","position","hex","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","args","fromBlock","toBlock","topics","topic0","logs","blocks","i","blockHash","getBlock","parseFloat","ethusd","getHistory","addressOrName","startBlock","endBlock","resolveName","startblock","endblock","sort","tx","creates","contractAddress","item","transactionResponse","timeStamp","timestamp","now","Date","getTime","checkNetworks","networks","chainId","ensAddress","median","values","maxDelta","slice","middle","Math","floor","a","b","abs","serialize","toString","Array","isArray","v","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","getPromise","wait","func","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","confirmations","transactions","quorum","tally","count","check","normalizedTally","waitForSync","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","getLogs","FallbackProvider","providers","providerConfigs","configOrProvider","index","stallTimeout","priority","freeze","total","networkOrReady","getNetwork","results","sendTransaction","getBlockNumber","array","j","random","tmp","shuffled","first","t0","inflightWeight","runner","staller","backend","waiting","push","race","errors","errorCode","props","reason","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","password","projectId","projectSecret","apiKeyObj","assertArgument","argument","user","JsonRpcBatchProvider","_nextId","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","_defaultProvider","JsonRpcProvider","Web3Provider"],"sourceRoot":""}